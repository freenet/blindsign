// Regular imported crates
extern crate blindsign;
extern crate curve25519_dalek;
extern crate rand;
extern crate sha3;

#[cfg(test)]
mod integration_test {
    use sha3::Sha3_512;

    use blindsign::{
        keypair::BlindKeypair,
        request::BlindRequest,
        session::BlindSession,
        signature::WiredUnblindedSigData,
    };

    #[test]
    fn session_with_random_msg() {
        // Generates a new keypair. The private key is used for creating blind
        // signatures on the blinded message, and the public key is used for
        // authenticating the unblinded signature on the unblinded message.
        let keypair = BlindKeypair::generate().unwrap();

        // Initiates a new blind session (bs) on the signer side, the first step of
        // which is generating of the value R' (rp).
        let (rp, bs) = BlindSession::new().unwrap();

        // Initiates a new blind request on the requester side, which is input R' and
        // generates e' (ep).
        let (ep, br) = BlindRequest::new::<Sha3_512>(&rp).unwrap();

        // Signs the e' value, which is essentially the blinded message hash. Produces
        // S' (sp), which is the blind signature.
        let sp = bs.sign_ep(&ep, keypair.private()).unwrap();

        // Forms a new blindly signed message object on the requester side, when
        // provided with the blind signature previously generated by the signer
        // side.
        let unblinded_signed_msg = br.gen_signed_msg(&sp).unwrap();

        // A demonstration of converting the blindly signed message between
        // internal representation and wired format for transmission over the
        // network.
        let wired = WiredUnblindedSigData::from(unblinded_signed_msg);
        let sig = wired.to_internal_format().unwrap();

        // A demonstration of authenticating the blind signature
        assert!(sig.authenticate(keypair.public()));
    }

    #[test]
    fn session_with_specific_msg() {
        // Generates a new keypair. The private key is used for creating blind
        // signatures on the blinded message, and the public key is used for
        // authenticating the unblinded signature on the unblinded message.
        let keypair = BlindKeypair::generate().unwrap();

        // Initiates a new blind session (bs) on the signer side, the first step of
        // which is generating of the value R' (rp).
        let (rp, bs) = BlindSession::new().unwrap();

        // Initiates a new blind request on the requester side, which is input R' and
        // generates e' (ep). In this case, using a specific message.
        let (ep, br) = BlindRequest::new_specific_msg::<Sha3_512, &str>(&rp, "specific").unwrap();

        // Signs the e' value, which is essentially the blinded message hash. Produces
        // S' (sp), which is the blind signature.
        let sp = bs.sign_ep(&ep, keypair.private()).unwrap();

        // Forms a new blindly signed message object on the requester side, when
        // provided with the blind signature previously generated by the signer
        // side.
        let unblinded_signed_msg = br.gen_signed_msg(&sp).unwrap();

        // A demonstration of converting the blindly signed message between
        // internal representation and wired format for transmission over the
        // network.
        let wired = WiredUnblindedSigData::from(unblinded_signed_msg);
        let sig = wired.to_internal_format().unwrap();

        // A demonstration of authenticating the blind signature
        assert!(sig.authenticate(keypair.public()));
    }

    #[test]
    fn test_valid_signature() {
        let keypair = BlindKeypair::generate().unwrap();
        let (rp, bs) = BlindSession::new().unwrap();
        let (ep, br) = BlindRequest::new::<Sha3_512>(&rp).unwrap();
        let sp = bs.sign_ep(&ep, keypair.private()).unwrap();
        let unblinded_signed_msg = br.gen_signed_msg(&sp).unwrap();
        let wired = WiredUnblindedSigData::from(unblinded_signed_msg);
        let sig = wired.to_internal_format().unwrap();

        assert!(sig.authenticate(keypair.public()), "Valid signature should authenticate successfully");
    }

    #[test]
    fn test_invalid_signature() {
        let keypair = BlindKeypair::generate().unwrap();
        let (rp, bs) = BlindSession::new().unwrap();
        let (ep, br) = BlindRequest::new::<Sha3_512>(&rp).unwrap();
        let sp = bs.sign_ep(&ep, keypair.private()).unwrap();
        let unblinded_signed_msg = br.gen_signed_msg(&sp).unwrap();

        // Convert to wired format and back, modifying one byte to create an invalid signature
        let mut wired_bytes = WiredUnblindedSigData::from(unblinded_signed_msg).to_bytes();
        wired_bytes[0] ^= 1; // Flip one bit in the first byte
        let invalid_wired = WiredUnblindedSigData(wired_bytes);
        let invalid_sig = invalid_wired.to_internal_format().unwrap();

        assert!(!invalid_sig.authenticate(keypair.public()), "Invalid signature should not authenticate");
    }

    #[test]
    fn test_wrong_public_key() {
        let keypair1 = BlindKeypair::generate().unwrap();
        let keypair2 = BlindKeypair::generate().unwrap();
        let (rp, bs) = BlindSession::new().unwrap();
        let (ep, br) = BlindRequest::new::<Sha3_512>(&rp).unwrap();
        let sp = bs.sign_ep(&ep, keypair1.private()).unwrap();
        let unblinded_signed_msg = br.gen_signed_msg(&sp).unwrap();
        let wired = WiredUnblindedSigData::from(unblinded_signed_msg);
        let sig = wired.to_internal_format().unwrap();

        assert!(!sig.authenticate(keypair2.public()), "Signature should not authenticate with wrong public key");
    }
}
